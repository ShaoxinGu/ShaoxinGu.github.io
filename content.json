{"meta":{"title":"Philip's Blog","subtitle":"不会美术的策划不是好程序。","description":"一个菜鸡程序猿的学习记录","author":"Philip","url":"https://shaoxingu.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-11T06:26:09.000Z","updated":"2019-10-18T08:03:24.609Z","comments":true,"path":"about/index.html","permalink":"https://shaoxingu.github.io/about/index.html","excerpt":"","text":"关于博客 这个博客是我的个人学习记录。 包括一些游戏开发相关的知识，和学习一些编程语言的笔记。 有时也会在这里记录下我的日常，写写我对人生的思考等等。 博客的搭建是基于Hexo的。 之前也试过用Jekyll，但是总觉得不够强大。 该项目托管在我的Github，由AppVeyor持续集成。 如果你也想搭一个这样的博客，可以上网搜相关的教程照着做。 有疑问的话也可以留言或邮件联系我。 关于我 我叫谷韶鑫，2018年毕业于广东外语外贸大学。 喜欢玩游戏、看电影和写代码。 如今我是一名游戏开发程序员。 客户端和服务端都懂一点，但是都不太行。 不论如何，一起变强吧！"},{"title":"categories","date":"2019-10-09T07:16:55.000Z","updated":"2019-10-18T08:03:24.609Z","comments":false,"path":"categories/index.html","permalink":"https://shaoxingu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-09T07:16:45.000Z","updated":"2019-10-18T08:03:24.609Z","comments":false,"path":"tags/index.html","permalink":"https://shaoxingu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Lua的闭包","slug":"Closure","date":"2019-10-18T08:03:24.609Z","updated":"2019-10-18T08:03:24.609Z","comments":true,"path":"2019/10/18/Closure/","link":"","permalink":"https://shaoxingu.github.io/2019/10/18/Closure/","excerpt":"","text":"闭包 闭包是一个函数以及它的 upvalues。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://shaoxingu.github.io/tags/Lua/"}]},{"title":"Lua实现面向对象","slug":"LuaOOP","date":"2019-10-18T08:03:24.609Z","updated":"2019-10-18T08:03:24.609Z","comments":true,"path":"2019/10/18/LuaOOP/","link":"","permalink":"https://shaoxingu.github.io/2019/10/18/LuaOOP/","excerpt":"","text":"概述以下描述出自《Program in Lua》中文版： ​ 一些面向对象的语言中提供了类的概念，作为创建对象的模板。在这些语言里，对象是类的实例。Lua 不存在类的概念，每个对象定义他自己的行为并拥有自己的形状（shape）。然而，依据基于原型（prototype）的语言比如 Self 和 NewtonScript，在 Lua中仿效类的概念并不难。在这些语言中，对象没有类。相反，每个对象都有一个 prototype（原型），当调用不属于对象的某些操作时，会最先会到 prototype 中查找这些操作。在这类语言中实现类（class）的机制，我们创建一个对象，作为其它对象的原型即可（原型对象为类，其它对象为类的 instance）。类与 prototype 的工作机制相同，都是定义了特定对象的行为。 实现方案方案一Lua的作者之一Roberto Lerusalimschy在《Program in Lua》书中推荐了一种实现LuaOO的方案，这种方案很简单也很容易理解。 在Lua里，类和实例都是table。在继承或实例化的时候，类会被赋值给实例或子类metatable的__index。 核心代码其实就这几行： 1234567Class = &#123;&#125;function Class:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oend 具体的案例如下： 123456789101112131415161718192021222324252627282930Base = &#123;&#125;function Base:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oendfunction Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")end--Child既可以说是Base类的实例，也可以说是Base类的子类，因为它们本质上都是table对象Child = Base:new()function Child:Test1() --Child类重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 方案二这个方案是我在工作中接触到的，算是方案一的升级版。 核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475-- 所有类都会继承自这个类，真·基类Class = &#123;__ClassType = \"Class\"&#125; ALL_CLASS = ALL_CLASS or &#123;&#125;function Class:Inherit(ClassName, o) o = o or &#123;&#125; o.mt = &#123; __index = o&#125; assert(ClassName, \"必须要有类名\") assert(not (ClassName and ALL_CLASS[ClassName]), string.format(\"该类已存在： %s\", ClassName)) o.__ClassType = ClassName ALL_CLASS[ClassName] = true o.__InheritMap = &#123;[self:GetType()] = true &#125; -- 记录继承类型 o.__InheritSelf = false if self.__InheritMap then for UpType, _ in pairs(self.__InheritMap) do o.__InheritMap[UpType] = true end end setmetatable(o, &#123;__index = self&#125;) return oendfunction Class:IsSubObj(ObjType) return self:GetTypeMap()[ObjType]endfunction Class:GetTypeMap() local clsSelf = getmetatable(self) if clsSelf then local Temp = clsSelf.__index if not Temp.__InheritSelf then Temp.__InheritMap[Temp:GetType()] = true Temp.__InheritSelf = true end return Temp.__InheritMap end return &#123;&#125;endfunction Class:New(...) local o = &#123;&#125; setmetatable(o, &#123;__index = self&#125;) if o.Ctor then o:Ctor(...) end --调用构造函数 return oendfunction Class:Ctor() endfunction Class:InClass() return true endfunction Class:OnCreate() endfunction Class:OnDestroy() endfunction Class:GetType() return self.__ClassType end--获取一个class的父类function Super(Class) return getmetatable(Class).__indexend--判断一个类是否是类的子类 &amp; 判断一个对象否是另一个类的实例function IsSub(Obj, Base) local Temp = Obj while 1 do --循环回溯metatable local mt = getmetatable(Temp) if mt then Temp = mt.__index if Temp == Base then return true end else return false end endend 示例如下： 1234567891011121314151617181920212223Base = Base or Class:Inherit(\"Base\")function Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")endChild = Child or Base:Inherit(\"Child\")function Child:Test1() --Child类重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 方案三这个是云风提供的方案：博客地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445local _class=&#123;&#125; function class(super) local class_type=&#123;&#125; class_type.ctor=false class_type.super=super class_type.new=function(...) local obj=&#123;&#125; do local create create = function(c,...) if c.super then create(c.super,...) end if c.ctor then c.ctor(obj,...) end end create(class_type,...) end setmetatable(obj,&#123; __index=_class[class_type] &#125;) return obj end local vtbl=&#123;&#125; _class[class_type]=vtbl setmetatable(class_type,&#123;__newindex= function(t,k,v) vtbl[k]=v end &#125;) if super then setmetatable(vtbl,&#123;__index= function(t,k) local ret=_class[super][k] vtbl[k]=ret return ret end &#125;) end return class_typeend 创建基类： 1234567891011121314base_type=class() -- 定义一个基类 base_type function base_type:ctor(x) -- 定义 base_type 的构造函数 print(\"base_type ctor\") self.x=xend function base_type:print_x()-- 定义一个成员函数 base_type:print_x print(self.x)end function base_type:hello() -- 定义另一个成员函数 base_type:hello print(\"hello base_type\")end 创建子类： 123456789test=class(base_type) -- 定义一个类 test 继承于 base_type function test:ctor() -- 定义 test 的构造函数 print(\"test ctor\")end function test:hello() -- 重载 base_type:hello 为 test:hello print(\"hello test\")end 测试： 123a=test.new(1) -- 输出两行，base_type ctor 和 test ctor 。这个对象被正确的构造了。a:print_x() -- 输出 1 ，这个是基类 base_type 中的成员函数。a:hello() -- 输出 hello test ，这个函数被重载了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://shaoxingu.github.io/tags/Lua/"}]},{"title":"UnityShader笔记【一】","slug":"ShaderNote1","date":"2019-10-18T08:03:24.609Z","updated":"2019-10-18T08:03:24.609Z","comments":true,"path":"2019/10/18/ShaderNote1/","link":"","permalink":"https://shaoxingu.github.io/2019/10/18/ShaderNote1/","excerpt":"","text":"应用阶段把数据加载到显存中 所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory， VRAM）中。这是因为，显卡对于显存的访问更快，而且大多数显卡对于RAM没有直接的访问权利。 渲染所需的数据除了纹理和网格之外，还包括顶点的位置信息、法线方向、顶点颜色、纹理坐标等。 当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的。 设置渲染状态 什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。 调用DrawCall DrawCall就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元（premitives）列表，而不会再包含任何材质信息。 当给定了一个DrawCall时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。 DrawCall的调用次数会直接影响性能，应该尽量减少DrawCall调用次数。 另外，CPU和GPU是并行工作的，通过一个命令缓冲区（可以理解为队列）来实现，CPU向命令缓冲区中添加命令，GPU向命令缓冲区读取命令。 几何阶段 在这个阶段，顶点将经历以下几个阶段： 模型坐标系 -&gt; 模型变换 -&gt; 世界坐标系 -&gt; 视图变换 -&gt; 观察坐标系 -&gt; 投影变换 -&gt; 规范化的观察空间 -&gt; 屏幕映射 -&gt; 屏幕坐标系 顶点着色器（Vertex Shader） 顶点着色器是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性，GPU可以利用本身的特征并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。 顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。 坐标变换，顾名思义，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。但需要注意的是，无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标从模型空间转换到齐次裁剪空间。 旧版Unity使用o.vertex = mul(UNITY_MVP, v.vertex);来完成顶点变换，而新版Unity使用o.vertex = UnityObjectToClipPos(v.vertex);来实现顶点变换。其功能就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Nomalized Device Coordinates, NDC)。 顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的Shader Model中，它还可以把数据发送给曲面细分着色器或几何着色器。 几何/曲面细分着色器 几何着色器和曲面细分着色器通常被合在一起成为几何/曲面细分着色器。 几何/曲面细分着色器是一个可选的操作。 几何着色器（Geometry Shader） 几何着色器的输入是顶点数据。它可以对图元的顶点进行操作，它可以高效地创建和删除几何图元。 曲面细分着色器（Tessellation Shader） 曲面细分着色器可以通过增加顶点，让现有的多边形网格更加逼近曲面。 裁剪（Clipping） 由于我们的场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，一个很自然的想法就是，那些不在摄像机视野范围内的物体不需要被处理。而裁剪就是为了完成这个目的而被提出来。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，以为它们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，这就是裁剪。例如，一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。 和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。 屏幕映射（Screen Mapping） 屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。 屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系（Window Coordinates）。这些值会一起被传递到光栅化阶段。 光栅化阶段三角形设置（Triangle Setup） 将几何阶段传过来的顶点数据进行处理，将顶点连成三角网格。 三角形遍历（Triangle Traversal） 三角形遍历的输入就是三角形设置的结果。 根据顶点信息，计算得到覆盖三角网格的像素位置，对于的这些像素就生成一个片元（fragment）。 而片元中每个像素的状态都是对三个顶点的信息进行插值得到的。 片元着色器（Fragment Shader） 这是一个可编程的阶段 根据之前的片元信息，计算每个片元的颜色值。 这个阶段可以完成很多重要的渲染技术，比如纹理贴图。 逐片元操作（Per-Fragment Operations） 在DirectX中又叫做输出合并阶段（Output-Merger）。 这里将每个片元的深度和颜色与帧缓存结合在一起。每个像素的颜色都是混合的结果。 生成屏幕图像 显示图像！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shaoxingu.github.io/tags/Unity/"},{"name":"Shader","slug":"Shader","permalink":"https://shaoxingu.github.io/tags/Shader/"}]},{"title":"单例模式","slug":"Singleton","date":"2019-10-18T08:03:24.609Z","updated":"2019-10-18T08:03:24.609Z","comments":true,"path":"2019/10/18/Singleton/","link":"","permalink":"https://shaoxingu.github.io/2019/10/18/Singleton/","excerpt":"","text":"单例模式 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。 单例模式或许是游戏开发中最常用的设计模式了。在开发游戏时，开发者通常会为每个子系统定义单例类。这些单例类负责统一管理某个系统，通常被称为管理器（manager）。例如常见的UI管理器（UIManager）、场景管理器（SceneManager）等。 描述 保证一个类只有一个实例：有时候，如果类存在多个实例就不能正确的运行。这种类的特点是，对这些类进行调用的时候必须接触之前所有的操作。如果这些操作的发生在不同的实例，一个实例就无法知道另一个实例的操作，也就无法正常地运行了。 提供了访问该实例的全局访问点： 有时候，游戏中的不同系统都会使用同一个类。 如果这些系统不能创建这个类的实例，那这个类就需要提供获取它实例的全局方法。 实现单例模式保证一个类只有一个实例，并且提供了该实例的全局访问点。 GPP（Game Programming Patterns）中以一个文件系统封装类作为例子。 经典的C++实现方案: 123456789101112131415class FileSystem&#123;public: static FileSystem&amp; instance() &#123; // 惰性初始化 if (instance_ == NULL) instance_ = new FileSystem(); return *instance_; &#125;private: FileSystem() &#123;&#125; static FileSystem* instance_;&#125;; 静态的instance_成员保存了一个类的实例， 私有的构造器保证了它是唯一的。 公开的静态方法instance()让任何地方的代码都能访问实例。 在首次被请求时，它同样负责惰性实例化该单例。 线程安全的现代C++实现方案： 123456789101112class FileSystem&#123;public: static FileSystem&amp; instance() &#123; static FileSystem *instance = new FileSystem(); return *instance; &#125;private: FileSystem() &#123;&#125;&#125;; 为什么我们使用它 如果没人用，就不必创建实例。 这种惰性初始化为节约内存和CPU资源带来了好处。 它在运行时实例化。 单例通常的替代方案是使用含有静态成员变量的类，但是静态成员是自动初始化的。编译器在main()运行前初始化静态变量，而且初始化的顺序不可控，这意味着它们的相互依赖不可靠。而单例模式的惰性初始化没有这个问题。 可继承单例。 单例可继承。这意味着单例模式可以配合多态性写出优美的代码。核心代码如下： 12345678910111213141516171819202122class FileSystem&#123;public: static FileSystem&amp; instance(); virtual ~FileSystem() &#123;&#125; virtual char* readFile(char* path) = 0; virtual void writeFile(char* path, char* contents) = 0;protected: FileSystem() &#123;&#125;&#125;;FileSystem&amp; FileSystem::instance()&#123;#if PLATFORM == PLAYSTATION3 static FileSystem *instance = new PS3FileSystem();#elif PLATFORM == WII static FileSystem *instance = new WiiFileSystem();#endif return *instance;&#125; 通过一个简单的编译器转换，我们把文件系统包装类绑定到合适的具体类型上。 整个代码库都可以使用FileSystem::instance()接触到文件系统，而无需和任何平台相关的代码耦合。耦合发生在为特定平台写的FileSystem类实现文件中。 为什么我们后悔使用它 它是一个全局变量 让理解更加困难：全局变量的使用让我们除了关心当前函数之外，还需要关心全局变量的状态。而由于全局变量的全局访问性，我们可能要追踪整个代码库才能找到某个静态变量在什么地方被赋予了错误的值。 促进了耦合的发生：全局变量具有全局可见性，新手程序员可以会在单例中#include 包含了其他模块的头文件。新手程序员用这种方法顺利地完成了任务，却破坏了框架留下了耦合。如果不用全局实例，那他这样做的时候将会遇到阻碍，这种阻碍会提醒他不该这样做。 通过控制对实例的访问，你控制了耦合。 对并行不友好： 当我们将某些东西转为全局变量时，我们创建了一块每个线程都能看到并访问的内存， 却不知道其他线程是否正在使用那块内存。 这种方式带来了死锁，竞争状态，以及其他很难解决的线程同步问题。 它能在你只有一个问题的时候解决两个 正如之前的描述里写的，单例模式解决了两个问题。如果我们只有其中一个问题呢？ 保证实例是唯一存在的是很有用的，但是谁告诉我们要让每个人都能接触到它？ 同样，全局接触很方便，但是必须禁止存在多个实例吗？这是一个奇怪的约束，比如我们为了便利的访问把一个类改成了单例，却发现这个类无法创建不同的实例了。 惰性初始化从你那里剥夺了控制权 如果初始化很耗时，而初始化发生在游戏的高潮部分，会导致可见的掉帧和断续的游戏体验 。 游戏通常需要严格管理在堆上分配的内存来避免碎片。如果系统在初始化时分配到了堆上。我们需要知道初始化在何时发生， 这样我们才可以控制内存待在堆的哪里。 那该如何是好 看看你是不是真正地需要类 有些时候我们并不需要管理器来管理某些对象，而是让这些对象管理自己。 将类限制为单一的实例 我们可以通过别的方法保证一个类只有单一实例，比如用一个bool值记录，而无需提供全局的接触点。 为了给实例提供方便的访问方法 传进来：在用其他更加繁杂的方法前，考虑一下这个解决方案。 从基类中获得：很多游戏架构有浅层但是宽泛的继承层次，通常只有一层深。举个例子，你也许有GameObject基类，每个游戏中的敌人或者对象都继承它。使用这样的架构，很大一部分游戏代码会存在于这些“子”推导类中。这就意味着这些类已经有了对同样事物的相同获取方法：它们的GameObject基类。我们可以利用这点： 12345678910111213141516class GameObject&#123;protected: Log&amp; getLog() &#123; return log_; &#125;private: static Log&amp; log_;&#125;;class Enemy : public GameObject&#123; void doSomething() &#123; getLog().write(\"I can log!\"); &#125;&#125;; 从已经是全局的东西中获取： 大多数代码库仍有一些全局可用对象，比如一个代表了整个游戏状态的Game或World对象。我们可以让现有的全局对象捎带需要的东西，来减少全局变量类的数目。不让Log，FileSystem和AudioPlayer都变成单例，而是这样做： 123456789101112131415161718class Game&#123;public: static Game&amp; instance() &#123; return instance_; &#125; // 设置log_, et. al. …… Log&amp; getLog() &#123; return *log_; &#125; FileSystem&amp; getFileSystem() &#123; return *fileSystem_; &#125; AudioPlayer&amp; getAudioPlayer() &#123; return *audioPlayer_; &#125;private: static Game instance_; Log *log_; FileSystem *fileSystem_; AudioPlayer *audioPlayer_;&#125;; 从服务定位器中获得： 定义一个类，存在的唯一目标就是为对象提供全局访问。 这种常见的模式被称为服务器定位模式，有单独讲它的章节。 Lua中的实现1234567891011121314151617181920Singleton = &#123;&#125;function Singleton:new(o) o = o or &#123;&#125; setmetatable(o,self) self.__index = self return oend function Singleton:Instance() if not self.instance then self.instance = self:new() end return self.instanceends1 = Singleton:Instance()s2 = Singleton:Instance()if s1 == s2 then print(\"两个对象是相同的实例\") end","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shaoxingu.github.io/tags/设计模式/"}]}]}