{"meta":{"title":"Philip's Blog","subtitle":"醉醉的博客","description":"一个菜鸡程序猿的学习记录","author":"Philip","url":"https://shaoxingu.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-10-09T07:16:45.000Z","updated":"2019-10-11T04:56:08.016Z","comments":false,"path":"tags/index.html","permalink":"https://shaoxingu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-09T07:16:55.000Z","updated":"2019-10-11T04:56:08.016Z","comments":false,"path":"categories/index.html","permalink":"https://shaoxingu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Lua实现面向对象","slug":"LuaOOP","date":"2019-10-11T04:56:08.016Z","updated":"2019-10-11T04:56:08.016Z","comments":true,"path":"2019/10/11/LuaOOP/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/LuaOOP/","excerpt":"","text":"概述以下描述出自《Program in Lua》中文版： ​ 一些面向对象的语言中提供了类的概念，作为创建对象的模板。在这些语言里，对象是类的实例。Lua 不存在类的概念，每个对象定义他自己的行为并拥有自己的形状（shape）。然而，依据基于原型（prototype）的语言比如 Self 和 NewtonScript，在 Lua中仿效类的概念并不难。在这些语言中，对象没有类。相反，每个对象都有一个 prototype（原型），当调用不属于对象的某些操作时，会最先会到 prototype 中查找这些操作。在这类语言中实现类（class）的机制，我们创建一个对象，作为其它对象的原型即可（原型对象为类，其它对象为类的 instance）。类与 prototype 的工作机制相同，都是定义了特定对象的行为。 实现方案方案一Lua的作者之一Roberto Lerusalimschy在《Program in Lua》书中推荐了一种实现LuaOO的方案，这种方案很简单也很容易理解。 在Lua里，类和实例都是table。在继承或实例化的时候，类会被赋值给实例或子类metatable的__index。 核心代码其实就这几行： 1234567Class = &#123;&#125;function Class:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oend 具体的案例如下： 123456789101112131415161718192021222324252627282930Base = &#123;&#125;function Base:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oendfunction Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")end--Child既可以说是Base类的实例，也可以说是Base类的子类，因为它们本质上都是table对象Child = Base:new()function Child:Test1() --Child类重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 方案二我在工作中接触到的算是方案一的升级版。 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Base = &#123;__ClassType = \"Base\"&#125;ALL_CLASS = ALL_CLASS or &#123;&#125;function Base:New(...) local o = &#123;&#125; setmetatable(o, &#123;__index = self&#125;) if o.Ctor then o:Ctor(...) end -- 调用构造函数 return oendfunction Base:Inherit(ClassName, o) o = o or &#123;&#125; o.mt = &#123; __index = o&#125; assert(ClassName, \"必须要有类名\") assert(not (ClassName and ALL_CLASS[ClassName]), string.format(\"该类已存在： %s\", ClassName)) o.__ClassType = ClassName ALL_CLASS[ClassName] = true o.__InheritMap = &#123;[self:GetType()] = true &#125; -- 记录继承类型 o.__InheritSelf = false if self.__InheritMap then for UpType, _ in pairs(self.__InheritMap) do o.__InheritMap[UpType] = true end end setmetatable(o, &#123;__index = self&#125;) return oendfunction Base:IsSubObj(ObjType) return self:GetTypeMap()[ObjType]endfunction Base:GetTypeMap() local clsSelf = getmetatable(self) if clsSelf then local Temp = clsSelf.__index if not Temp.__InheritSelf then Temp.__InheritMap[Temp:GetType()] = true Temp.__InheritSelf = true end return Temp.__InheritMap end return &#123;&#125;endfunction Base:Ctor() endfunction Base:InClass() return true endfunction Base:OnCreate() endfunction Base:OnDestroy() endfunction Base:GetType() return self.__ClassType end 与之配套的方法： 1234567891011121314151617181920-- 获取一个类的父类 &amp; 获取一个实例的构造类function Super(Class) return getmetatable(Class).__indexend-- 判断一个类是否是类的子类 &amp; 判断一个对象否是另一个类的实例function IsSub(Obj, Base) local Temp = Obj while 1 do --循环回溯metatable local mt = getmetatable(Temp) if mt then Temp = mt.__index if Temp == Base then return true end else return false end endend","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://shaoxingu.github.io/tags/Lua/"}]},{"title":"UnityShader笔记【一】","slug":"ShaderNote1","date":"2019-10-11T04:56:08.016Z","updated":"2019-10-11T04:56:08.016Z","comments":true,"path":"2019/10/11/ShaderNote1/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/ShaderNote1/","excerpt":"","text":"应用阶段把数据加载到显存中 所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory， VRAM）中。这是因为，显卡对于显存的访问更快，而且大多数显卡对于RAM没有直接的访问权利。 渲染所需的数据除了纹理和网格之外，还包括顶点的位置信息、法线方向、顶点颜色、纹理坐标等。 当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的。 设置渲染状态 什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。 调用DrawCall DrawCall就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元（premitives）列表，而不会再包含任何材质信息。 当给定了一个DrawCall时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。 DrawCall的调用次数会直接影响性能，应该尽量减少DrawCall调用次数。 另外，CPU和GPU是并行工作的，通过一个命令缓冲区（可以理解为队列）来实现，CPU向命令缓冲区中添加命令，GPU向命令缓冲区读取命令。 几何阶段顶点着色器（Vertex Shader） 顶点着色器是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性，GPU可以利用本身的特征并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。 顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。 坐标变换，顾名思义，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。但需要注意的是，无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标从模型空间转换到齐次裁剪空间。 旧版Unity使用o.vertex = mul(UNITY_MVP, v.vertex);来完成顶点变换，而新版Unity使用o.vertex = UnityObjectToClipPos(v.vertex);来实现顶点变换。其功能就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Nomalized Device Coordinates, NDC)。 顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的Shader Model中，它还可以把数据发送给曲面细分着色器或几何着色器。 裁剪（Clipping） 由于我们的场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，一个很自然的想法就是，那些不在摄像机视野范围内的物体不需要被处理。而裁剪就是为了完成这个目的而被提出来。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，以为它们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，这就是裁剪。例如，一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。 和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。 屏幕映射（Screen Mapping） 屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。 屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系（Window Coordinates）。这些值会一起被传递到光栅化阶段。 光栅化阶段三角形设置三角形遍历片元着色器逐片元操作生成屏幕图像","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shaoxingu.github.io/tags/Unity/"},{"name":"Shader","slug":"Shader","permalink":"https://shaoxingu.github.io/tags/Shader/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-11T04:56:08.016Z","updated":"2019-10-11T04:56:08.016Z","comments":true,"path":"2019/10/11/hello-world/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}