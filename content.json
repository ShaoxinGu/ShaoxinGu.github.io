{"meta":{"title":"Philip's Blog","subtitle":"不会美术的策划不是好程序。","description":"一个菜鸡程序猿的学习记录","author":"Philip","url":"https://shaoxingu.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-11T06:26:09.000Z","updated":"2019-10-14T06:15:08.028Z","comments":true,"path":"about/index.html","permalink":"https://shaoxingu.github.io/about/index.html","excerpt":"","text":"关于博客 这个博客是我的个人学习记录。 包括一些游戏开发相关的知识，和学习一些编程语言的笔记。 有时也会在这里记录下我的日常，写写我对人生的思考等等。 博客的搭建是基于Hexo的。 之前也试过用Jekyll，但是总觉得不够强大。 该项目托管在我的Github，由AppVeyor持续集成。 如果你也想搭一个这样的博客，可以上网搜相关的教程照着做。 有疑问的话也可以留言或邮件联系我。 关于我 我叫谷韶鑫，2018年毕业于广东外语外贸大学。 喜欢玩游戏、看电影和写代码。 如今我是一名游戏开发程序员。 客户端和服务端都懂一点，但是都不太行。 不论如何，一起变强吧！"},{"title":"categories","date":"2019-10-09T07:16:55.000Z","updated":"2019-10-14T06:15:08.028Z","comments":false,"path":"categories/index.html","permalink":"https://shaoxingu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-09T07:16:45.000Z","updated":"2019-10-14T06:15:08.028Z","comments":false,"path":"tags/index.html","permalink":"https://shaoxingu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Lua实现面向对象","slug":"LuaOOP","date":"2019-10-14T06:15:08.028Z","updated":"2019-10-14T06:15:08.028Z","comments":true,"path":"2019/10/14/LuaOOP/","link":"","permalink":"https://shaoxingu.github.io/2019/10/14/LuaOOP/","excerpt":"","text":"概述以下描述出自《Program in Lua》中文版： ​ 一些面向对象的语言中提供了类的概念，作为创建对象的模板。在这些语言里，对象是类的实例。Lua 不存在类的概念，每个对象定义他自己的行为并拥有自己的形状（shape）。然而，依据基于原型（prototype）的语言比如 Self 和 NewtonScript，在 Lua中仿效类的概念并不难。在这些语言中，对象没有类。相反，每个对象都有一个 prototype（原型），当调用不属于对象的某些操作时，会最先会到 prototype 中查找这些操作。在这类语言中实现类（class）的机制，我们创建一个对象，作为其它对象的原型即可（原型对象为类，其它对象为类的 instance）。类与 prototype 的工作机制相同，都是定义了特定对象的行为。 实现方案方案一Lua的作者之一Roberto Lerusalimschy在《Program in Lua》书中推荐了一种实现LuaOO的方案，这种方案很简单也很容易理解。 在Lua里，类和实例都是table。在继承或实例化的时候，类会被赋值给实例或子类metatable的__index。 核心代码其实就这几行： 1234567Class = &#123;&#125;function Class:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oend 具体的案例如下： 123456789101112131415161718192021222324252627282930Base = &#123;&#125;function Base:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oendfunction Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")end--Child既可以说是Base类的实例，也可以说是Base类的子类，因为它们本质上都是table对象Child = Base:new()function Child:Test1() --Child类重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 方案二这个方案是我在工作中接触到的，算是方案一的升级版。 核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475-- 所有类都会继承自这个类，真·基类Class = &#123;__ClassType = \"Class\"&#125; ALL_CLASS = ALL_CLASS or &#123;&#125;function Class:Inherit(ClassName, o) o = o or &#123;&#125; o.mt = &#123; __index = o&#125; assert(ClassName, \"必须要有类名\") assert(not (ClassName and ALL_CLASS[ClassName]), string.format(\"该类已存在： %s\", ClassName)) o.__ClassType = ClassName ALL_CLASS[ClassName] = true o.__InheritMap = &#123;[self:GetType()] = true &#125; -- 记录继承类型 o.__InheritSelf = false if self.__InheritMap then for UpType, _ in pairs(self.__InheritMap) do o.__InheritMap[UpType] = true end end setmetatable(o, &#123;__index = self&#125;) return oendfunction Class:IsSubObj(ObjType) return self:GetTypeMap()[ObjType]endfunction Class:GetTypeMap() local clsSelf = getmetatable(self) if clsSelf then local Temp = clsSelf.__index if not Temp.__InheritSelf then Temp.__InheritMap[Temp:GetType()] = true Temp.__InheritSelf = true end return Temp.__InheritMap end return &#123;&#125;endfunction Class:New(...) local o = &#123;&#125; setmetatable(o, &#123;__index = self&#125;) if o.Ctor then o:Ctor(...) end --调用构造函数 return oendfunction Class:Ctor() endfunction Class:InClass() return true endfunction Class:OnCreate() endfunction Class:OnDestroy() endfunction Class:GetType() return self.__ClassType end--获取一个class的父类function Super(Class) return getmetatable(Class).__indexend--判断一个类是否是类的子类 &amp; 判断一个对象否是另一个类的实例function IsSub(Obj, Base) local Temp = Obj while 1 do --循环回溯metatable local mt = getmetatable(Temp) if mt then Temp = mt.__index if Temp == Base then return true end else return false end endend 示例如下： 1234567891011121314151617181920212223Base = Base or Class:Inherit(\"Base\")function Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")endChild = Child or Base:Inherit(\"Child\")function Child:Test1() --Child类重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 方案三这个是云风提供的方案：博客地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445local _class=&#123;&#125; function class(super) local class_type=&#123;&#125; class_type.ctor=false class_type.super=super class_type.new=function(...) local obj=&#123;&#125; do local create create = function(c,...) if c.super then create(c.super,...) end if c.ctor then c.ctor(obj,...) end end create(class_type,...) end setmetatable(obj,&#123; __index=_class[class_type] &#125;) return obj end local vtbl=&#123;&#125; _class[class_type]=vtbl setmetatable(class_type,&#123;__newindex= function(t,k,v) vtbl[k]=v end &#125;) if super then setmetatable(vtbl,&#123;__index= function(t,k) local ret=_class[super][k] vtbl[k]=ret return ret end &#125;) end return class_typeend 创建基类： 1234567891011121314base_type=class() -- 定义一个基类 base_type function base_type:ctor(x) -- 定义 base_type 的构造函数 print(\"base_type ctor\") self.x=xend function base_type:print_x()-- 定义一个成员函数 base_type:print_x print(self.x)end function base_type:hello() -- 定义另一个成员函数 base_type:hello print(\"hello base_type\")end 创建子类： 123456789test=class(base_type) -- 定义一个类 test 继承于 base_type function test:ctor() -- 定义 test 的构造函数 print(\"test ctor\")end function test:hello() -- 重载 base_type:hello 为 test:hello print(\"hello test\")end 测试： 123a=test.new(1) -- 输出两行，base_type ctor 和 test ctor 。这个对象被正确的构造了。a:print_x() -- 输出 1 ，这个是基类 base_type 中的成员函数。a:hello() -- 输出 hello test ，这个函数被重载了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://shaoxingu.github.io/tags/Lua/"}]},{"title":"UnityShader笔记【一】","slug":"ShaderNote1","date":"2019-10-14T06:15:08.028Z","updated":"2019-10-14T06:15:08.028Z","comments":true,"path":"2019/10/14/ShaderNote1/","link":"","permalink":"https://shaoxingu.github.io/2019/10/14/ShaderNote1/","excerpt":"","text":"应用阶段把数据加载到显存中 所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory， VRAM）中。这是因为，显卡对于显存的访问更快，而且大多数显卡对于RAM没有直接的访问权利。 渲染所需的数据除了纹理和网格之外，还包括顶点的位置信息、法线方向、顶点颜色、纹理坐标等。 当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的。 设置渲染状态 什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。 调用DrawCall DrawCall就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元（premitives）列表，而不会再包含任何材质信息。 当给定了一个DrawCall时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。 DrawCall的调用次数会直接影响性能，应该尽量减少DrawCall调用次数。 另外，CPU和GPU是并行工作的，通过一个命令缓冲区（可以理解为队列）来实现，CPU向命令缓冲区中添加命令，GPU向命令缓冲区读取命令。 几何阶段 在这个阶段，顶点将经历以下几个阶段： 模型坐标系 -&gt; 模型变换 -&gt; 世界坐标系 -&gt; 视图变换 -&gt; 观察坐标系 -&gt; 投影变换 -&gt; 规范化的观察空间 -&gt; 屏幕映射 -&gt; 屏幕坐标系 顶点着色器（Vertex Shader） 顶点着色器是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性，GPU可以利用本身的特征并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。 顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。 坐标变换，顾名思义，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。但需要注意的是，无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标从模型空间转换到齐次裁剪空间。 旧版Unity使用o.vertex = mul(UNITY_MVP, v.vertex);来完成顶点变换，而新版Unity使用o.vertex = UnityObjectToClipPos(v.vertex);来实现顶点变换。其功能就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Nomalized Device Coordinates, NDC)。 顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的Shader Model中，它还可以把数据发送给曲面细分着色器或几何着色器。 几何/曲面细分着色器 几何着色器和曲面细分着色器通常被合在一起成为几何/曲面细分着色器。 几何/曲面细分着色器是一个可选的操作。 几何着色器（Geometry Shader） 几何着色器的输入是顶点数据。它可以对图元的顶点进行操作，它可以高效地创建和删除几何图元。 曲面细分着色器（Tessellation Shader） 曲面细分着色器可以通过增加顶点，让现有的多边形网格更加逼近曲面。 裁剪（Clipping） 由于我们的场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，一个很自然的想法就是，那些不在摄像机视野范围内的物体不需要被处理。而裁剪就是为了完成这个目的而被提出来。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，以为它们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，这就是裁剪。例如，一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。 和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。 屏幕映射（Screen Mapping） 屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。 屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系（Window Coordinates）。这些值会一起被传递到光栅化阶段。 光栅化阶段三角形设置（Triangle Setup） 将几何阶段传过来的顶点数据进行处理，将顶点连成三角网格。 三角形遍历（Triangle Traversal） 三角形遍历的输入就是三角形设置的结果。 根据顶点信息，计算得到覆盖三角网格的像素位置，对于的这些像素就生成一个片元（fragment）。 而片元中每个像素的状态都是对三个顶点的信息进行插值得到的。 片元着色器（Fragment Shader） 这是一个可编程的阶段 根据之前的片元信息，计算每个片元的颜色值。 这个阶段可以完成很多重要的渲染技术，比如纹理贴图。 逐片元操作（Per-Fragment Operations） 在DirectX中又叫做输出合并阶段（Output-Merger）。 这里将每个片元的深度和颜色与帧缓存结合在一起。每个像素的颜色都是混合的结果。 生成屏幕图像 显示图像！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shaoxingu.github.io/tags/Unity/"},{"name":"Shader","slug":"Shader","permalink":"https://shaoxingu.github.io/tags/Shader/"}]},{"title":"单例模式","slug":"Singleton","date":"2019-10-14T06:15:08.028Z","updated":"2019-10-14T06:15:08.028Z","comments":true,"path":"2019/10/14/Singleton/","link":"","permalink":"https://shaoxingu.github.io/2019/10/14/Singleton/","excerpt":"","text":"单例模式 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shaoxingu.github.io/tags/设计模式/"}]}]}