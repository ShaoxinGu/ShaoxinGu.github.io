{"meta":{"title":"Philip's Blog","subtitle":"醉醉的博客","description":"一个菜鸡程序猿的学习记录","author":"Philip","url":"https://shaoxingu.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-10-09T07:16:45.000Z","updated":"2019-10-11T02:35:33.097Z","comments":false,"path":"tags/index.html","permalink":"https://shaoxingu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-09T07:16:55.000Z","updated":"2019-10-11T02:35:33.097Z","comments":false,"path":"categories/index.html","permalink":"https://shaoxingu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"lua的面向对象","slug":"LuaOOP","date":"2019-10-11T02:35:33.097Z","updated":"2019-10-11T02:35:33.097Z","comments":true,"path":"2019/10/11/LuaOOP/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/LuaOOP/","excerpt":"","text":"概述Lua中并没有严格意义上的类和对象的概念，但是可以利用Lua的metatable来模拟类和对象。Lua的作者在PIL中推荐了一种实现LuaOO的方案，这种方案很简单也很容易理解。在lua里，类和实例都是table。在继承或实例化的时候，类会将自己设置为实例或子类的metatable。这样当实例或子类在索引不到某个属性或方法的时候，会调用metatable的__index元方法，也就是查找父类的方法。核心代码其实就这几行： 1234567class = &#123;&#125;function class:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oend 具体的案例如下： 123456789101112131415161718192021222324252627282930Base = &#123;&#125;function Base:new (o) o = o or &#123;&#125; -- create object if user does not provide one setmetatable(o, self) self.__index = self return oendfunction Base:Test1() print(\"Base Test1\")endfunction Base:Test2() print(\"Base Test2\")end--Child既可以说是Base类的实例，也可以说是Base类的子类Child = Base:new()function Child:Test1() --Child重写了Test1方法 print(\"Child Test1\")endlocal a = Base:new() --生成一个Base类的实例a:Test1() --将打印\"Base Test1\"a:Test2() --将打印\"Base Test2\"local b = Child:new() --生成一个Child类的实例b:Test1() --将打印\"Child Test1\"b:Test2() --将打印\"Base Test2\",调用的是父类的方法 可以看到，这里的类和实例都是table，并没有本质上的区别。这并不影响我们的初衷——代码复用，甚至提供了其他面向对象语言所没有的灵活性，比如你可以直接给实例定义新的方法。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://shaoxingu.github.io/tags/Lua/"}]},{"title":"UnityShader笔记【一】","slug":"ShaderNote1","date":"2019-10-11T02:35:33.097Z","updated":"2019-10-11T02:35:33.097Z","comments":true,"path":"2019/10/11/ShaderNote1/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/ShaderNote1/","excerpt":"","text":"应用阶段把数据加载到显存中 所有渲染所需的数据都需要从硬盘（Hard Disk Drive，HDD）中加载到系统内存（Random Access Memory，RAM）中。然后，网格和纹理等数据又被加载到显卡上的存储空间——显存（Video Random Access Memory， VRAM）中。这是因为，显卡对于显存的访问更快，而且大多数显卡对于RAM没有直接的访问权利。 渲染所需的数据除了纹理和网格之外，还包括顶点的位置信息、法线方向、顶点颜色、纹理坐标等。 当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的。 设置渲染状态 什么是渲染状态呢？一个通俗的解释就是，这些状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等。如果我们没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。 调用DrawCall DrawCall就是一个命令，它的发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元（premitives）列表，而不会再包含任何材质信息。 当给定了一个DrawCall时，GPU就会根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些漂亮的像素。 DrawCall的调用次数会直接影响性能，应该尽量减少DrawCall调用次数。 另外，CPU和GPU是并行工作的，通过一个命令缓冲区（可以理解为队列）来实现，CPU向命令缓冲区中添加命令，GPU向命令缓冲区读取命令。 几何阶段顶点着色器（Vertex Shader） 顶点着色器是完全可编程的，它通常用于实现顶点的空间变换、顶点着色等功能。 顶点着色器是流水线的第一个阶段，它的输入来自于CPU。顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性，GPU可以利用本身的特征并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。 顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。 坐标变换，顾名思义，就是对顶点的坐标（即位置）进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。但需要注意的是，无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标从模型空间转换到齐次裁剪空间。 旧版Unity使用o.vertex = mul(UNITY_MVP, v.vertex);来完成顶点变换，而新版Unity使用o.vertex = UnityObjectToClipPos(v.vertex);来实现顶点变换。其功能就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Nomalized Device Coordinates, NDC)。 顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的Shader Model中，它还可以把数据发送给曲面细分着色器或几何着色器。 裁剪（Clipping） 由于我们的场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，一个很自然的想法就是，那些不在摄像机视野范围内的物体不需要被处理。而裁剪就是为了完成这个目的而被提出来。 一个图元与摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外。完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，以为它们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，这就是裁剪。例如，一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。 和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。 屏幕映射（Screen Mapping） 屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。 屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系（Window Coordinates）。这些值会一起被传递到光栅化阶段。 光栅化阶段三角形设置三角形遍历片元着色器逐片元操作生成屏幕图像","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://shaoxingu.github.io/categories/学习笔记/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shaoxingu.github.io/tags/Unity/"},{"name":"Shader","slug":"Shader","permalink":"https://shaoxingu.github.io/tags/Shader/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-11T02:35:33.097Z","updated":"2019-10-11T02:35:33.097Z","comments":true,"path":"2019/10/11/hello-world/","link":"","permalink":"https://shaoxingu.github.io/2019/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}